/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Value of maximum period in ticks */
#define PERIOD_MAX_TICKS          10000U

/* Value of period steps in ticks */
#define PERIOD_STEPS_TICKS        50U

/* Value of duty steps in ticks */
#define DUTY_STEPS_TICKS          50U

/* Delay for smooth up/down count phases */
#define UPDATE_DELAY_MS           15U

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{
    cy_rslt_t result;

    /* Variable for storing character read from UART terminal */
    uint8_t uartReadValue;

    /* TCPWM CC0 register value, default duty cycle - 50% */
    uint32_t cc0BufferVal = PERIOD_MAX_TICKS / 2;
    /* TCPWM period register value */
    uint32_t periodBufferVal = PERIOD_MAX_TICKS;

    /* Mode switches */
    bool isDutyIncremented = true;
    bool isPeriodIncremented = true;
    bool isDutyMode = true;

#if defined (CY_DEVICE_SECURE)
    cyhal_wdt_t wdt_obj;

    /* Clear watchdog timer so that it doesn't trigger a reset */
    result = cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms());
    CY_ASSERT(CY_RSLT_SUCCESS == result);
    cyhal_wdt_free(&wdt_obj);
#endif /* #if defined (CY_DEVICE_SECURE) */

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io to use the debug UART port */
    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX,
            CY_RETARGET_IO_BAUDRATE);

    /* retarget-io init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");
    printf("********************************************************************************\r\n");
    printf("                       TCPWM PWM On The Fly Update Example\r\n");
    printf("********************************************************************************\r\n\r\n");

    printf("This code example generates a PWM signal on pin P6_1 (Arduino connector J16.9).\r\n");
    printf("The duty cycle or frequency is updated on the fly.\r\n\r\n");
    printf("Press 'm' key to toggle between Duty and Frequency mode.\r\n\r\n");

    /* Initialize TCPWM in PWM mode */
    if (CY_TCPWM_SUCCESS != Cy_TCPWM_PWM_Init(TCPWM_PWM_HW, TCPWM_PWM_NUM, &TCPWM_PWM_config))
    {
        /* Handle error if initialization is unsuccessful */
        CY_ASSERT(0);
    }

    /* Enable the PWM counter */
    Cy_TCPWM_PWM_Enable(TCPWM_PWM_HW, TCPWM_PWM_NUM);

    /* Start the PWM */
    Cy_TCPWM_TriggerReloadOrIndex_Single(TCPWM_PWM_HW, TCPWM_PWM_NUM);

    /* Display current mode */
    printf("Current Mode: %s \r\n", ((isDutyMode == true) ? "Duty" : "Frequency"));

    for (;;)
    {
        /* Check if the mode is Duty or Frequency */
        if (isDutyMode == true)
        {
            /* Duty Mode */
            /* Check for duty up/down counting state */
            if (isDutyIncremented == true)
            {
                /* Increase CC0 buffer value such that it doesn't exceed maximum period */
                if (cc0BufferVal < (PERIOD_MAX_TICKS - DUTY_STEPS_TICKS - 1))
                {
                    cc0BufferVal += DUTY_STEPS_TICKS;
                }
                else
                {
                    /* Change to down count state */
                    isDutyIncremented = false;
                }
            }
            else
            {
                /* Decrease CC0 buffer value till minimum value */
                if (cc0BufferVal > (DUTY_STEPS_TICKS + 1))
                {
                    cc0BufferVal -= DUTY_STEPS_TICKS;
                }
                else
                {
                    /* Change to up count state */
                    isDutyIncremented = true;
                }
            }

            /* In Duty mode, the period is constant */
            periodBufferVal = PERIOD_MAX_TICKS;
        }
        else
        {
            /* Frequency Update Mode */
            /* Check for period up/down counting state */
            if (isPeriodIncremented == true)
            {
                /* Increase period buffer value such that it doesn't exceed maximum period */
                if (periodBufferVal < (PERIOD_MAX_TICKS - PERIOD_STEPS_TICKS - 1))
                {
                    periodBufferVal += PERIOD_STEPS_TICKS;
                }
                else
                {
                    /* Change to down count state */
                    isPeriodIncremented = false;
                }
            }
            else
            {
                /* Decrease period buffer value till minimum value */
                if (periodBufferVal > (PERIOD_STEPS_TICKS + 1))
                {
                    periodBufferVal -= PERIOD_STEPS_TICKS;
                }
                else
                {
                    /* Change to up count state */
                    isPeriodIncremented = true;
                }
            }

            /* In frequency mode, the duty cycle is always at 50% */
            cc0BufferVal = periodBufferVal / 2;
        }

        /* Set period buffer and capture/compare buffer registers */
        Cy_TCPWM_PWM_SetPeriod1(TCPWM_PWM_HW, TCPWM_PWM_NUM, periodBufferVal);
        Cy_TCPWM_PWM_SetCompare0BufVal(TCPWM_PWM_HW, TCPWM_PWM_NUM, cc0BufferVal);

        /* Trigger swap event effective at next terminal count event */
        Cy_TCPWM_TriggerCaptureOrSwap_Single(TCPWM_PWM_HW, TCPWM_PWM_NUM);

        /* Check if 'Enter' key was pressed */
        if (cyhal_uart_getc(&cy_retarget_io_uart_obj, &uartReadValue, 1) == CY_RSLT_SUCCESS)
        {
            if (uartReadValue == 'm' )
            {
                /* Toggle the mode (duty or frequency) whenever 'Enter' key is pressed */
                isDutyMode = (isDutyMode == true) ? false : true;

                /* Move cursor 1 line above and erase the line*/
                printf("\x1b[1F\x1b[0K");
                printf("Current Mode: %s \r\n", ((isDutyMode == true) ? "Duty" : "Frequency"));
            }
        }

        /* Delay for smooth up/down count phases */
        Cy_SysLib_Delay(UPDATE_DELAY_MS);
    }
}
